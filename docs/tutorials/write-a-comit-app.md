---
id: write-a-comit-app
title: Write your first COMIT-app
sidebar_label: Write your first COMIT-app
---

This is a typescript tutorial for creating your first COMIT-app. 
In this tutorial we build two simple command-line application that use the COMIT protocol to execute a Bitcoin to Ethereum atomic swap locally on your machine.

This tutorial is designed for Javascript/Typescript developers that want to integrate atomic swaps into their application.
The tutorial teaches you:

1. How to setup an actor using the dev-environment described in [Tooling and Setup](../getting-started/comit-scripts.md).
2. How to use the negotiation classes of the comit-sdk.
3. How to execute a swap using the comit-sdk.

## Introduction

The goal of the tutorial is to have a simple command-line application that handles the negotiation and execution of an atomic swap for both sides of a trade.

For the negotiation phase we introduce **two roles**, the **maker** and the **taker**. The maker creates orders and publishes them. The taker takes orders published by the maker.
In this tutorial our maker has Bitcoin and wants Ether. Our taker has Ether and wants Bitcoin.

This tutorial uses the comit-js-sdk's [MakerNegotiator](../comit-sdk/classes/_negotiation_maker_negotiator_.httpservice.md) and [TakerNegotiator](../comit-sdk/classes/_negotiation_taker_negotiator_.negotiator.md) classes for negotiating the trade. 
This tutorial does not tackle the problem of "finding a trading partner".
It is assumed that the taker already knows how to reach the "order-server" of the maker.

When it comes to the execution of the swap there are also two roles, Alice and Bob, that represent the cryptographic roles of the swap protocol. 
Alice is the role that comes up with the secret. She funds and redeems first. Bob is the role that receives the secret hash from Alice prior to swap execution.
After the negotiation the taker will default to the role of Alice. The maker will default to Bob. 
This means that Alice (the taker) has to fund on the Ethereum side and redeem Bob's (the maker) Bitcoin.
Bob funds the Bitcoin side and redeems Alice's Ether.

Let's jump right into the setup.

## Setup

In the [previous section about comit-scripts](../getting-started/comit-scripts.md) we took a look on how to use comit-scripts to setup your development environment.
The same setup is used for this tutorial.

For getting started please create a new project using the `create` command of create-comit-app:

```
yarn create comit-app my-first-comit-app
```

Navigate into the newly created `my-first-comit-app` folder and start the development environment:

```
cd my-first-comit-app
yarn install && yarn start-env
```

An Ethereum `parity` and a Bitcoin `bitcoind` node as well as one `cnd` node for the maker and one `cnd` node for the taker are now started.
Keep the development environment running in this terminal!

### Understanding the environment

The environment created through comit-scripts's `start-env` gives you pre-funded accounts that we will use in this tutorial.
All variables related to the environment are stored in the `${HOME}/.create-comit-app/env` file.

In your project folder you find an `index.js` file that is currently the entry point for running the application.
Open a new terminal and run:
```shell script
yarn start
```

This will print the environment information of the dev-environment started through `start-env`:

```
Environment configuration:
Bitcoin HD keys:
1.  tprv8ZgxMBicQKsPfARyVrLY2LGqCxi7EgzMQP5eLtQ6izLiCD52vdHMxgFc9VhFzfvur9nndNFdJnwF46nPWcEbf64bYp9pK23abbxjfPEyBNi
2.  tprv8ZgxMBicQKsPdAY3E7VwbiH9gc9GCRNAew7R6UMW1J4m1tfYXkxctDZJba88BvtFnaJQyDTZm9dxBrz2w3BmEBcTCMPnuWPG6hhntu3gEoG
Bitcoin node P2P URI:  127.0.0.1:52879
Ethereum private keys:
1.  34e64385ef7c9dfab1bb8d0015b263e4b15b76afc3535af0a9ed0584ae49024d
2.  06354eef150a1909cf1f414c5888f6d762ecbd9bca247de4ba534fd66481d36e
Ethereum node HTTP URL:  http://127.0.0.1:52369
ERC20 token contract address:  0x62d69f6867a0a084c6d313943dc22023bc263691
cnd HTTP API URLs:
1.  http://127.0.0.1:53129
2.  http://127.0.0.1:53164
```

By default `start-env` will create two accounts for both Bitcoin and Ethereum and fund them.
Initial funding is **10 BTC** and **1000 ETH**.
We will use these accounts for our maker and taker when creating the maker and taker COMIT-apps. 

Additionally `start-env` creates an ERC20 contract for swapping from/to ERC20 tokens. This is not relevant for this tutorial.

The connection information for the Bitcoin node, Ethereum node and the two cnd nodes is printed as well.

### Typescript configuration

The example generated by create-comit-app is pure Javascript.
We have to configure Typescript in order to use it in our project.

Open the `package.json` and add these two lines in the `devDependencies` section:

```json
"ts-node": "^8.6.2",
"typescript": "^3.7.5",
```

### Prepare Maker and Taker app

Since the goal of this tutorial is to have the maker and taker run separately, we need one file that will represent the COMIT-app of the maker and one for the taker.
We will use typescript in this tutorial.

Let's create two files in the project directory `my-first-comit-app`:

1. `maker.ts` for the COMIT-app representing the maker
2. `taker.ts` for the COMIT-app representing the taker

Both apps will be runnable command line applications, so let's add a main function to `maker.ts`:

```$typescript
(async function main() {
    console.log("COMIT Maker app");
    process.exit();
})();
```

and `taker.ts`:

```$typescript
(async function main() {
    console.log("COMIT Taker app");
    process.exit();
})();
```

Additionally we have to add commands to run these two actors in the `package.json`:

```json
"scripts": {
  ...
  "maker": "ts-node ./src/maker.ts",
  "taker": "ts-node ./src/taker.ts",
  ...
}
```

With this in place we can already run our maker app:

```shell script
yarn run maker
```

and taker app:
```shell script
yarn run taker
```

### Initialising the actors

In this section we use the [Actor](../comit-sdk/interfaces/_actor_.actor.md) interface of the comit-sdk to initialise the maker and taker actors.
We will use the Bitcoin and Ethereum accounts created through `start-env` for initialising the actors.

Through the actor we have access to the wallets and the [ComitClient](../comit-sdk/classes/_comit_client_.comitclient.md) which is used as a wrapper for the communication with cnd.  

#### Initialise the maker actor

Let's focus on the maker for the beginning.
`start-env` has provided us with two Bitcoin and two Ethereum accounts indexed with `0` and `1`.
Let's use the Bitcoin and Ethereum account indexed with `0` for the maker.

From the `index.js` file we already know how to load the environment using the `dotenv` package:

```typescript
const configPath = path.join(os.homedir(), ".create-comit-app", "env");
dotenv.config({path: configPath});
```

First we initialise the Bitcoin wallet using the `InMemoryBitcoinWallet` provided by the comit-sdk:
```typescript
    const bitcoinWallet = await InMemoryBitcoinWallet.newInstance(
        "regtest",
        process.env.BITCOIN_P2P_URI!,
        process.env[`BITCOIN_HD_KEY_${0}`]!
    );
    // Waiting for the Bitcoin wallet to read the balance
    await new Promise(r => setTimeout(r, 1000));
```

Then we initialise the `EthereumWallet` provided bt the comit-sdk:

```typescript
    const ethereumWallet = new EthereumWallet(
            process.env.ETHEREUM_NODE_HTTP_URL!,
            process.env[`ETHEREUM_KEY_${0}`]!
        );
```

Now we can use the `createActor` helper function of the comit-sdk to intialise the actor.

```typescript
let maker = await createActor(
        bitcoinWallet,
        ethereumWallet,
        process.env[`HTTP_URL_CND_${0}`]!
    );
```

Let's print the balance of the maker to see how much BTC and ETH he has before the swap:

```typescript
console.log(
        "[Maker] Bitcoin balance: %f, Ether balance: %f",
        (await maker.bitcoinWallet.getBalance()).toFixed(2),
        parseFloat(
            formatEther(await maker.ethereumWallet.getBalance())
        ).toFixed(2)
    );
```

Note that we are using the `formatEther` function from `ethers/utils` to format the ether properly.

Your `maker.ts` file should now look like this:

```typescript
import * as dotenv from "dotenv";
import * as os from "os";
import * as path from "path";
import {createActor, EthereumWallet, InMemoryBitcoinWallet} from "comit-sdk";
import { formatEther } from "ethers/utils";

(async function main() {
    console.log("COMIT Maker app");

    const configPath = path.join(os.homedir(), ".create-comit-app", "env");
    dotenv.config({path: configPath});

    const bitcoinWallet = await InMemoryBitcoinWallet.newInstance(
        "regtest",
        process.env.BITCOIN_P2P_URI!,
        process.env[`BITCOIN_HD_KEY_${0}`]!
    );
    // Waiting for the Bitcoin wallet to read the balance
    await new Promise(r => setTimeout(r, 1000));

    const ethereumWallet = new EthereumWallet(
        process.env.ETHEREUM_NODE_HTTP_URL!,
        process.env[`ETHEREUM_KEY_${0}`]!
    );

    let maker = await createActor(
        bitcoinWallet,
        ethereumWallet,
        process.env[`HTTP_URL_CND_${0}`]!
    );

    console.log(
        "[Maker] Bitcoin balance: %f, Ether balance: %f",
        (await maker.bitcoinWallet.getBalance()).toFixed(2),
        parseFloat(
            formatEther(await maker.ethereumWallet.getBalance())
        ).toFixed(2)
    );

    process.exit();
})();
```

When running `yarn run maker` you should see:

```
yarn run v1.22.0
$ ts-node ./src/maker.ts
COMIT Maker app
[Maker] Bitcoin balance: 10, Ether balance: 1000
✨  Done in 7.19s.
```

#### Initialise the taker actor

For the taker we will have a similar setup as for the maker. (This could of course be pulled out into a library later.)

Similar to the maker we will load the Bitcoin and Ethereum account from the environment, initialise the wallets and create the actor using the comit-sdk's `createActor` function.
Note that we will use the Bitcoin and Ethereum account as well as the cnd instance with index `1` for the taker.

In the end our `taker.ts` file should look like this:

```typescript
import * as dotenv from "dotenv";
import * as os from "os";
import * as path from "path";
import {createActor, EthereumWallet, InMemoryBitcoinWallet} from "comit-sdk";
import { formatEther } from "ethers/utils";

(async function main() {
    console.log("COMIT Taker app");

    const configPath = path.join(os.homedir(), ".create-comit-app", "env");
    dotenv.config({path: configPath});

    const bitcoinWallet = await InMemoryBitcoinWallet.newInstance(
        "regtest",
        process.env.BITCOIN_P2P_URI!,
        process.env[`BITCOIN_HD_KEY_${1}`]!
    );
    // Waiting for the Bitcoin wallet to read the balance
    await new Promise(r => setTimeout(r, 1000));

    const ethereumWallet = new EthereumWallet(
        process.env.ETHEREUM_NODE_HTTP_URL!,
        process.env[`ETHEREUM_KEY_${1}`]!
    );

    let taker = await createActor(
        bitcoinWallet,
        ethereumWallet,
        process.env[`HTTP_URL_CND_${1}`]!
    );

    console.log(
        "[Taker] Bitcoin balance: %f, Ether balance: %f",
        (await taker.bitcoinWallet.getBalance()).toFixed(2),
        parseFloat(
            formatEther(await taker.ethereumWallet.getBalance())
        ).toFixed(2)
    );

    process.exit();
})();
```

When running `yarn run taker` we should see:

```
yarn run v1.22.0
$ ts-node ./src/taker.ts
COMIT Taker app
[Taker] Bitcoin balance: 10, Ether balance: 1000
✨  Done in 9.34s.
```

## Implementation of negotiating a Swap

Now that both sides of the trade (maker and taker) are set up, let's start implementing the actual trade!

First we focus on the negotiation between maker and taker. 
The maker will create and publish an order that the taker can then find and take. 
Once the taker has taken the order the execution is triggered.

This tutorial uses the comit-js-sdk's [MakerNegotiator](../comit-sdk/classes/_negotiation_maker_negotiator_.httpservice.md) and [TakerNegotiator](../comit-sdk/classes/_negotiation_taker_negotiator_.negotiator.md) classes for negotiating the trade. 
This tutorial does not tackle the problem of "finding a trading partner".
It is assumed that the taker already knows how to reach the "order-server" of the maker.

### Maker creates an Order

We start with the maker again (in `maker.ts`).
For the maker we use the `MakerNegotiator` class of the comit-sdk to create a simple order HTTP-server using nodejs-express.

> Note by Daniel: It is quite confusing that one has to initialise the MakerNegotiator with the execution params. We should somehow change that. 
> One possibility would be to add a function "setExecutionParams" that explicitly deals with the exec-params. 
> Doing this in the constructor of the Negotiator does not feel right.

Note, that after the negotiation the `MakerNegotiator` will trigger the execution of the swap, hence it has to be initialised with the necessary execution information:

1. The [ComitClient](../comit-sdk/classes/_comit_client_.comitclient.md) used by the maker to communicate with his cnd node for executing the swap.
2. The execution parameters of the maker provided for the taker (so they can reach an agreement on how to execute the swap):
    1. Connection information to the maker's cnd (`peerId` and `addressHint`).
    2. The `expiry` for the alpha (Ethereum) and `beta` (Bitcoin) ledger.
    3. The configuration for the repective ledger (the taker should know on e.g. which network the maker wants to execute the swap).

The `ComitClient` was already initialised through the actor initialisation in the previous section. 

Let's define the execution parameters that the maker is suggesting:

```typescript
const executionParameters = {
    // Connection information for the comit network daemon.
    // The maker has to provide this to the taker for the execution phase,
    // so that the taker's comit network daemon can message the maker's comit network daemon.
    peer: {
        peer_id: maker.peerId,
        address_hint: maker.addressHint,
    },
    // The expiry time for the taker.
    alpha_expiry: moment().unix() + 7200,
    // The expiry time for the maker
    beta_expiry: moment().unix() + 3600,
    // The network the swap will be executed on.
    ledgers: {
        bitcoin: { network: "regtest" },
        ethereum: { chain_id: 17 },
    },
};
```

For calculating the expiry timestamps we use the `moment` module. You will have to add it to your `dependencies` in your `package.json`:
```json
"moment": "^2.24.0",
```

> Note by Daniel: `TryParams` is confusing here. It is hard to explain why `maxTimeoutSecs` is set to 1000 here. It is generally tough to explain this...
> Especially because it is actually concerning the execution and not the negotiation. The concerns are mixed here. I feel this needs a redesign.

In addition to the parameters mentioned above, the maker is also providing `TryParams`, that define how often his `ComitClient` will poll the swap status from cnd and a maximum timeout.
```typescript
const tryParams = { maxTimeoutSecs: 1000, tryIntervalSecs: 0.1 };
```

Now we have all the parameters for the `MakerNegotiator` assembled and can create an instance:

```typescript
const makerNegotiator = new MakerNegotiator(
    maker.comitClient,
    executionParameters,
    tryParams
);
```

Before we go on, let's define how the `MakerNegotiator` HTTP API shall be exposed to the taker:

```typescript
 // Start the HTTP service used to publish orders.
// The maker's HTTP service will be served at http://localhost:2318/
await makerNegotiator.listen(2318, "localhost");
```

At this point you `maker.ts` file should look simliar to this:

```typescript
import * as dotenv from "dotenv";
import * as os from "os";
import * as path from "path";
import {createActor, EthereumWallet, InMemoryBitcoinWallet, MakerNegotiator} from "comit-sdk";
import { formatEther } from "ethers/utils";
import moment = require("moment");

(async function main() {
    console.log("COMIT Maker app");

    const configPath = path.join(os.homedir(), ".create-comit-app", "env");
    dotenv.config({path: configPath});

    const bitcoinWallet = await InMemoryBitcoinWallet.newInstance(
        "regtest",
        process.env.BITCOIN_P2P_URI!,
        process.env[`BITCOIN_HD_KEY_${0}`]!
    );
    // Waiting for the Bitcoin wallet to read the balance
    await new Promise(r => setTimeout(r, 1000));

    const ethereumWallet = new EthereumWallet(
        process.env.ETHEREUM_NODE_HTTP_URL!,
        process.env[`ETHEREUM_KEY_${0}`]!
    );

    let maker = await createActor(
        bitcoinWallet,
        ethereumWallet,
        process.env[`HTTP_URL_CND_${0}`]!
    );

    console.log(
        "[Maker] Bitcoin balance: %f, Ether balance: %f",
        (await maker.bitcoinWallet.getBalance()).toFixed(2),
        parseFloat(
            formatEther(await maker.ethereumWallet.getBalance())
        ).toFixed(2)
    );

    const executionParameters = {
        // Connection information for the comit network daemon.
        // The maker has to provide this to the taker for the execution phase,
        // so that the taker's comit network daemon can message the maker's comit network daemon.
        peer: {
            peer_id: maker.peerId,
            address_hint: maker.addressHint,
        },
        // The expiry time for the taker.
        alpha_expiry: moment().unix() + 7200,
        // The expiry time for the maker
        beta_expiry: moment().unix() + 3600,
        // The network the swap will be executed on.
        ledgers: {
            bitcoin: { network: "regtest" },
            ethereum: { chain_id: 17 },
        },
    };

    const tryParams = { maxTimeoutSecs: 1000, tryIntervalSecs: 0.1 };

    const makerNegotiator = new MakerNegotiator(
        maker.comitClient,
        executionParameters,
        tryParams
    );

    await makerNegotiator.listen(2318, "localhost");

    process.exit();
})();
```

When running `yarn maker` it prints:

```
yarn run v1.22.0
$ ts-node ./src/maker.ts
COMIT Maker app
[Maker] Bitcoin balance: 10, Ether balance: 1000
Maker's Negotiation Service is listening on localhost:2318.
✨  Done in 4.43s.
```

### Maker publishes an Order

The `MakerNegotiator` allows us to create and publish an [Order](../comit-sdk/interfaces/_negotiation_order_.order.md) as defined in the comit-sdk.
Let's create an order of 50 ether for 1 bitcoin, meaning that the maker is offering 50 ether and asking for 1 bitcoin:

```typescript
// Create an order to be published.
const order = {
    id: "123",
    validUntil: moment().unix() + 300,
    ask: {
        nominalAmount: "50",
        asset: "ether",
        ledger: "ethereum",
    },
    bid: {
        nominalAmount: "1",
        asset: "bitcoin",
        ledger: "bitcoin",
    },
};
```

We can now publish the order for the taker:

```typescript
// Publish the order so the taker can take it.
makerNegotiator.addOrder(order);
```

And finally we "tell" the world that we have an order available:

```typescript
const link = makerNegotiator.getUrl();
console.log(`Waiting for someone to take my order at: ${link}`);
```

Your COMIt-app could publish this link on a forum or social media so takers can connect to you.

One last thing to do.
When a taker takes the order created by the maker, it will trigger the swap execution right away.
The maker thus has to wait for a taker to taker the order to commence with the execution.

```typescript
// Wait for a taker to accept the order and send a swap request through the comit network daemon (cnd).
let swapHandle;
// This loop runs until a swap request was sent from the taker to the maker
// and a swap is waiting to be processed on the maker's side.
while (!swapHandle) {
    await new Promise(r => setTimeout(r, 1000));
    // Check for incoming swaps in the comit node daemon (cnd) of the maker.
    swapHandle = await maker.comitClient.getOngoingSwaps().then(swaps => {
        if (swaps) {
            return swaps[0];
        } else {
            return undefined;
        }
    });
}
```

The maker uses the `ComitClient` to look for incoming swaps.

> Notes by Daniel: This is also a bit confusing. I feel the names should be harmonised (swap on the taker side, swap-handle on the maker)
> Additionally: Is there any matching logic that checks if the swap matches the order on the maker side? (If so it is not obvious in the example...)
> Not sure how to make this better, but I think we should iterate on it again.

At this stage your maker application should look similar to this:

```typescript
import * as dotenv from "dotenv";
import * as os from "os";
import * as path from "path";
import {createActor, EthereumWallet, InMemoryBitcoinWallet, MakerNegotiator} from "comit-sdk";
import { formatEther } from "ethers/utils";
import moment = require("moment");

(async function main() {
    console.log("COMIT Maker app");

    const configPath = path.join(os.homedir(), ".create-comit-app", "env");
    dotenv.config({path: configPath});

    const bitcoinWallet = await InMemoryBitcoinWallet.newInstance(
        "regtest",
        process.env.BITCOIN_P2P_URI!,
        process.env[`BITCOIN_HD_KEY_${0}`]!
    );
    // Waiting for the Bitcoin wallet to read the balance
    await new Promise(r => setTimeout(r, 1000));

    const ethereumWallet = new EthereumWallet(
        process.env.ETHEREUM_NODE_HTTP_URL!,
        process.env[`ETHEREUM_KEY_${0}`]!
    );

    let maker = await createActor(
        bitcoinWallet,
        ethereumWallet,
        process.env[`HTTP_URL_CND_${0}`]!
    );

    console.log(
        "[Maker] Bitcoin balance: %f, Ether balance: %f",
        (await maker.bitcoinWallet.getBalance()).toFixed(2),
        parseFloat(
            formatEther(await maker.ethereumWallet.getBalance())
        ).toFixed(2)
    );

    const executionParameters = {
        // Connection information for the comit network daemon.
        // The maker has to provide this to the taker for the execution phase,
        // so that the taker's comit network daemon can message the maker's comit network daemon.
        peer: {
            peer_id: maker.peerId,
            address_hint: maker.addressHint,
        },
        // The expiry time for the taker.
        alpha_expiry: moment().unix() + 7200,
        // The expiry time for the maker
        beta_expiry: moment().unix() + 3600,
        // The network the swap will be executed on.
        ledgers: {
            bitcoin: { network: "regtest" },
            ethereum: { chain_id: 17 },
        },
    };

    const tryParams = { maxTimeoutSecs: 1000, tryIntervalSecs: 0.1 };

    const makerNegotiator = new MakerNegotiator(
        maker.comitClient,
        executionParameters,
        tryParams
    );

    await makerNegotiator.listen(2318, "localhost");

    const order = {
        id: "123",
        validUntil: moment().unix() + 300,
        ask: {
            nominalAmount: "50",
            asset: "ether",
            ledger: "ethereum",
        },
        bid: {
            nominalAmount: "1",
            asset: "bitcoin",
            ledger: "bitcoin",
        },
    };

    makerNegotiator.addOrder(order);

    const link = makerNegotiator.getUrl();
    console.log(`Waiting for someone to take my order at: ${link}`);

    // Wait for a taker to accept the order and send a swap request through the comit network daemon (cnd).
    let swapHandle;
    // This loop runs until a swap request was sent from the taker to the maker
    // and a swap is waiting to be processed on the maker's side.
    while (!swapHandle) {
        await new Promise(r => setTimeout(r, 1000));
        // Check for incoming swaps in the comit node daemon (cnd) of the maker.
        swapHandle = await maker.comitClient.getOngoingSwaps().then(swaps => {
            if (swaps) {
                return swaps[0];
            } else {
                return undefined;
            }
        });
    }

    process.exit();
})();
```

When running `yarn maker` it prints:
```
yarn run v1.22.0
$ ts-node ./src/maker.ts
COMIT Maker app
[Maker] Bitcoin balance: 10, Ether balance: 1000
Maker's Negotiation Service is listening on localhost:2318.
Waiting for someone to take my order at: http://127.0.0.1:2318

```

The maker app is now waiting on the taker to initiate the swap for execution.
The order is published and a taker can come, take it and by doing so start the swap execution.

Let's keep the maker app running in this terminal and focus on the Taker side to consume the order and start swap execution!

### Taker requests an Order

Similar to the maker, there is a negotiation class for the taker as well, called `TakerNegotiator`.

In order to initialise the `TakerNegotiator` we have to provide the maker's order server URL:

```typescript
const makerNegotiatorUrl = "http://localhost:2318/";
```

The maker must share this information with the taker through some channgel (e.g. Telegram group).

Knowing where to fetch order the taker can now initialise the `TakerNegotiator`.
Similar to the maker he also has to provide his `ComitClient` (initialised with the actor) for swap execution.

```typescript
const takerNegotiator = new TakerNegotiator(
    taker.comitClient,
    makerNegotiatorUrl
);
```

The taker can now request an order from the maker by defining a filter criteria.
The criteria defines what the taker would like to trade:

```typescript
const criteria = {
    buy: {
        ledger: "bitcoin",
        asset: "bitcoin",
        minNominalAmount: "1",
    },
    sell: {
        ledger: "ethereum",
        asset: "ether",
    },
    minRate: 0.001,
};
```

This is needed, because the taker might not know what the maker has to offer and if it is still available.
In a more advanced implementation such kind of functionality would be provided by an orderbook.

With the criteria the taker can now request an order from the maker:

```typescript
    const order = await takerNegotiator.getOrder(criteria);
```

Let's log the rate offered by the maker:

```typescript
console.log("Rate offered: ", order.getOfferedRate().toString());
```

At this stage your taker application should look similar to this:

```typescript
import * as dotenv from "dotenv";
import * as os from "os";
import * as path from "path";
import {createActor, EthereumWallet, InMemoryBitcoinWallet, TakerNegotiator} from "comit-sdk";
import { formatEther } from "ethers/utils";

(async function main() {
    console.log("COMIT Taker app");

    const configPath = path.join(os.homedir(), ".create-comit-app", "env");
    dotenv.config({path: configPath});

    const bitcoinWallet = await InMemoryBitcoinWallet.newInstance(
        "regtest",
        process.env.BITCOIN_P2P_URI!,
        process.env[`BITCOIN_HD_KEY_${1}`]!
    );
    // Waiting for the Bitcoin wallet to read the balance
    await new Promise(r => setTimeout(r, 1000));

    const ethereumWallet = new EthereumWallet(
        process.env.ETHEREUM_NODE_HTTP_URL!,
        process.env[`ETHEREUM_KEY_${1}`]!
    );

    let taker = await createActor(
        bitcoinWallet,
        ethereumWallet,
        process.env[`HTTP_URL_CND_${1}`]!
    );

    console.log(
        "[Taker] Bitcoin balance: %f, Ether balance: %f",
        (await taker.bitcoinWallet.getBalance()).toFixed(2),
        parseFloat(
            formatEther(await taker.ethereumWallet.getBalance())
        ).toFixed(2)
    );

    const makerNegotiatorUrl = "http://localhost:2318/";

    const takerNegotiator = new TakerNegotiator(
        taker.comitClient,
        makerNegotiatorUrl
    );

    const criteria = {
        buy: {
            ledger: "bitcoin",
            asset: "bitcoin",
            minNominalAmount: "1",
        },
        sell: {
            ledger: "ethereum",
            asset: "ether",
        },
        minRate: 0.001,
    };

    const order = await takerNegotiator.getOrder(criteria);

    console.log("Rate offered: ", order.getOfferedRate().toString());

    process.exit();
})();

```

Note, that in order to properly retrieve an order at the taker side, the maker application has to run at this stage!
Ensure that your maker app is still running and then start the taker app with `yarn taker` - it should print:


```
yarn run v1.22.0
$ ts-node ./src/taker.ts
COMIT Taker app
[Taker] Bitcoin balance: 10, Ether balance: 1000
Rate offered:  0.02
✨  Done in 6.64s.
```

Since the taker only requests the offer and prints the rate taker application terminates after that.
Let's move on to taking the order and initiating swap execution!

### Taker takes the order

If the taker once to commence and take the requested order, he simple takes it:

```typescript
const swap = await order.take();
```

This gices the taker an instance of the `Swap` class of the comit-sdk.

## Implementation of executing a Swap

Let's stay on the taker side.
By taking the `Order` the taker has notified the maker that he is ready to start executing the swap.

## Extending this tutorial

Extensions include several solution spaces
